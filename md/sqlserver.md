# 特性介绍

1. sqlserver引擎默认使用1433端口，多实例时默认采用动态端口，防火墙要配置固定端口策略时，需要修改配置固定实例使用的端口

2. sqlserver代理，管理定时任务的组件，并且可以监控作业执行情况，必要时触发通知报警。sqlserver代理中的计划（cron）和作业是分离的，可以创建一个计划作用在多个作业上

3. sqlserver所有权组（也称架构，默认为dbo），早期版本就是建表用户，后面才和建表用户分离；主要是用来做权限管理，对象通过所有权组分类，赋权时可以给用户添加某个所有权组下所有对象的访问权限，简化权限操作

4. 复制数据库最常用的是备份还原法，备份开始时会对数据冻结，备份过程中发生的变更不会包含在本次备份中

5. sqlserver的数据和事务日志是分文件保存的，资源有限的情况下，只将日志文件放到固态硬盘上，也是可以大幅度提升写入的性能的，但对读取操作几乎无影响；另外可以配置文件组，数据写入文件组时，sqlserver会根据文件的可用空间比例将数据写入到每个文件，通过并行读写多个磁盘提高性能（需要主机有多个磁盘接口，电源供电能力也要能跟上，相当于raid了，raid是对操作系统级的所有读写有效，文件组需要针对性配置，只对sqlserver可见）

6. 系统数据库，master保存sqlserver系统级信息，包括数据库信息、用户信息、配置信息；msdb保存代理作业信息；tempdb保存临时表

7. sqlserver排序规则支持多个层级的配置，实例、数据库、表、列都可以单独指定排序规则，不同排序规则的列进行关联或比较时会报错，解决方法是修改规则或者在查询时使用collate临时指定排序规则

8. 只有在大型delete或删除表操作后，才建议执行收缩功能。官网也不建议开启auto shrink，数据库收缩可能会阻止针对数据的查询操作

# 索引

## 聚集索引

每个表只能有一个聚集索引，它是表数据物理存储的顺序，使用primary key约束时自动为该列添加聚集索引，聚集索引如果未使用unique属性，则数据库引擎会自动向表添加一个四字节的唯一标识（不可见，仅供引擎内部使用）

聚集索引采用b+树存储，其中根节点和中间节点是目录节点，叶子节点上存储数据；使用聚集索引查询数据时，通过b+树可快速找到数据位置（叶子节点），范围查询时，找到初始位置数据后，后面的数据都是物理相邻的；对聚集索引列使用order by功能，也无需使用数据库引擎的排序功能，因为行本来就是按照聚集索引有序的了

一般情况下，聚集索引包含的列越少越好（宽索引造成b+树维护的开销，并且每个非聚集索引树的叶子节点也会存储聚集索引，太大了会造成空间浪费）；适合聚集索引的列：唯一或者包含多个不同值，需要按顺序访问（比如查找100到200范围的数据，只要找到100，后面的值都是按顺序物理相邻的，连续往后读取就行了）；频繁修改的列不适合作为聚集索引列，修改会导致整行数据移动（引擎要保证行数据有序）

聚集索引键长度不能超过900字节（这个是实际长度不是定义长度，可以定义更大长度，到实际插入时内容超过这个长度才会报错），非聚集索引长度要求则是1700字节，所以大字段是做不了索引的

## 非聚集索引

和聚集索引一样，也是采用b+树，区别是基础表的数据不会按非聚集索引顺序存储，非聚集索引树的叶子节点保存的是聚集索引的键（没聚集索引就存放引擎自己生成的定位器）；定义了索引的列，只能修改是否非空或者varchar的长度，其他修改需要先删除索引

## 索引建立注意事项

1. 避免对频繁更新的表建立过多索引，并且索引应该保持较窄（索引包含的列要少），因为更改数据的操作需要同步更新索引，也会耗时

2. 对于大量查询而不修改的表，应该建立多个索引，这样可供查询优化器选择的就多，从而选择最佳索引方式

3. 对小表增加的索引可能不会有优化效果，因为查询优化器处理索引的时间可能已经超过扫描全表的时间了

4. 视图的索引也会加入到查询优化器的选择中，即使查询没有显式使用视图

# 物理连接过程

sqlserver查询优化器在执行表连接操作时，会根据表大小、索引情况、内存等因素选择不同的物理连接策略

## 嵌套循环连接

连接左表很小，右表很大且在连接列上设置了索引的情况，nested loops是最快的方式，它需要的io和比较都比较少；处理过程是左表作为输入表，逐行在右表里搜索匹配的行

## 合并连接

两个连接的表并不小，连接的字段有序，采用合并连接；过程是从两表的第一行开始匹配，两表都逐行往下移（如果有重复值，下移后另一边要返回重复开始的行）

## 哈希连接

最通用，处理未排序的大型非索引表，连接时查询优化器首先选择数据较少的表作为生成输入，扫描整个生成输入，在内存中生成哈希表（将键映射到存储位置，实现平均时间复杂度为o(1)的查找、插入和删除操作），然后扫描另一个表，逐行通过哈希表判断是否匹配；在数据过大时，还可以分块处理

## 
